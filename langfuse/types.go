// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package langfuse

import (
	"encoding/json"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for AnnotationQueueObjectType.
const (
	AnnotationQueueObjectTypeOBSERVATION AnnotationQueueObjectType = "OBSERVATION"
	AnnotationQueueObjectTypeTRACE       AnnotationQueueObjectType = "TRACE"
)

// Defines values for AnnotationQueueStatus.
const (
	COMPLETED AnnotationQueueStatus = "COMPLETED"
	PENDING   AnnotationQueueStatus = "PENDING"
)

// Defines values for ChatMessageWithPlaceholders0Type.
const (
	Chatmessage ChatMessageWithPlaceholders0Type = "chatmessage"
)

// Defines values for ChatMessageWithPlaceholders1Type.
const (
	Placeholder ChatMessageWithPlaceholders1Type = "placeholder"
)

// Defines values for CommentObjectType.
const (
	CommentObjectTypeOBSERVATION CommentObjectType = "OBSERVATION"
	CommentObjectTypePROMPT      CommentObjectType = "PROMPT"
	CommentObjectTypeSESSION     CommentObjectType = "SESSION"
	CommentObjectTypeTRACE       CommentObjectType = "TRACE"
)

// Defines values for CreatePromptRequest0Type.
const (
	CreatePromptRequest0TypeChat CreatePromptRequest0Type = "chat"
)

// Defines values for CreatePromptRequest1Type.
const (
	CreatePromptRequest1TypeText CreatePromptRequest1Type = "text"
)

// Defines values for DatasetStatus.
const (
	ACTIVE   DatasetStatus = "ACTIVE"
	ARCHIVED DatasetStatus = "ARCHIVED"
)

// Defines values for GetScoresResponseData0DataType.
const (
	GetScoresResponseData0DataTypeNUMERIC GetScoresResponseData0DataType = "NUMERIC"
)

// Defines values for GetScoresResponseData1DataType.
const (
	GetScoresResponseData1DataTypeCATEGORICAL GetScoresResponseData1DataType = "CATEGORICAL"
)

// Defines values for GetScoresResponseData2DataType.
const (
	GetScoresResponseData2DataTypeBOOLEAN GetScoresResponseData2DataType = "BOOLEAN"
)

// Defines values for IngestionEvent0Type.
const (
	TraceCreate IngestionEvent0Type = "trace-create"
)

// Defines values for IngestionEvent1Type.
const (
	ScoreCreate IngestionEvent1Type = "score-create"
)

// Defines values for IngestionEvent2Type.
const (
	SpanCreate IngestionEvent2Type = "span-create"
)

// Defines values for IngestionEvent3Type.
const (
	SpanUpdate IngestionEvent3Type = "span-update"
)

// Defines values for IngestionEvent4Type.
const (
	GenerationCreate IngestionEvent4Type = "generation-create"
)

// Defines values for IngestionEvent5Type.
const (
	GenerationUpdate IngestionEvent5Type = "generation-update"
)

// Defines values for IngestionEvent6Type.
const (
	EventCreate IngestionEvent6Type = "event-create"
)

// Defines values for IngestionEvent7Type.
const (
	SdkLog IngestionEvent7Type = "sdk-log"
)

// Defines values for IngestionEvent8Type.
const (
	ObservationCreate IngestionEvent8Type = "observation-create"
)

// Defines values for IngestionEvent9Type.
const (
	ObservationUpdate IngestionEvent9Type = "observation-update"
)

// Defines values for MediaContentType.
const (
	Applicationjson        MediaContentType = "application/json"
	Applicationmsword      MediaContentType = "application/msword"
	ApplicationoctetStream MediaContentType = "application/octet-stream"
	Applicationpdf         MediaContentType = "application/pdf"
	ApplicationvndMsExcel  MediaContentType = "application/vnd.ms-excel"
	Applicationxml         MediaContentType = "application/xml"
	Applicationzip         MediaContentType = "application/zip"
	Audioaac               MediaContentType = "audio/aac"
	Audioflac              MediaContentType = "audio/flac"
	Audiomp3               MediaContentType = "audio/mp3"
	Audiomp4               MediaContentType = "audio/mp4"
	Audiompeg              MediaContentType = "audio/mpeg"
	Audiooga               MediaContentType = "audio/oga"
	Audioogg               MediaContentType = "audio/ogg"
	Audiowav               MediaContentType = "audio/wav"
	Imagebmp               MediaContentType = "image/bmp"
	Imagegif               MediaContentType = "image/gif"
	Imagejpeg              MediaContentType = "image/jpeg"
	Imagejpg               MediaContentType = "image/jpg"
	Imagepng               MediaContentType = "image/png"
	ImagesvgXml            MediaContentType = "image/svg+xml"
	Imagetiff              MediaContentType = "image/tiff"
	Imagewebp              MediaContentType = "image/webp"
	Textcss                MediaContentType = "text/css"
	Textcsv                MediaContentType = "text/csv"
	Texthtml               MediaContentType = "text/html"
	Textplain              MediaContentType = "text/plain"
	Videomp4               MediaContentType = "video/mp4"
	Videowebm              MediaContentType = "video/webm"
)

// Defines values for MembershipRole.
const (
	ADMIN  MembershipRole = "ADMIN"
	MEMBER MembershipRole = "MEMBER"
	OWNER  MembershipRole = "OWNER"
	VIEWER MembershipRole = "VIEWER"
)

// Defines values for ModelUsageUnit.
const (
	CHARACTERS   ModelUsageUnit = "CHARACTERS"
	IMAGES       ModelUsageUnit = "IMAGES"
	MILLISECONDS ModelUsageUnit = "MILLISECONDS"
	REQUESTS     ModelUsageUnit = "REQUESTS"
	SECONDS      ModelUsageUnit = "SECONDS"
	TOKENS       ModelUsageUnit = "TOKENS"
)

// Defines values for ObservationLevel.
const (
	DEBUG   ObservationLevel = "DEBUG"
	DEFAULT ObservationLevel = "DEFAULT"
	ERROR   ObservationLevel = "ERROR"
	WARNING ObservationLevel = "WARNING"
)

// Defines values for ObservationType.
const (
	EVENT      ObservationType = "EVENT"
	GENERATION ObservationType = "GENERATION"
	SPAN       ObservationType = "SPAN"
)

// Defines values for Prompt0Type.
const (
	Prompt0TypeChat Prompt0Type = "chat"
)

// Defines values for Prompt1Type.
const (
	Prompt1TypeText Prompt1Type = "text"
)

// Defines values for Score0DataType.
const (
	Score0DataTypeNUMERIC Score0DataType = "NUMERIC"
)

// Defines values for Score1DataType.
const (
	Score1DataTypeCATEGORICAL Score1DataType = "CATEGORICAL"
)

// Defines values for Score2DataType.
const (
	Score2DataTypeBOOLEAN Score2DataType = "BOOLEAN"
)

// Defines values for ScoreDataType.
const (
	ScoreDataTypeBOOLEAN     ScoreDataType = "BOOLEAN"
	ScoreDataTypeCATEGORICAL ScoreDataType = "CATEGORICAL"
	ScoreDataTypeNUMERIC     ScoreDataType = "NUMERIC"
)

// Defines values for ScoreSource.
const (
	ANNOTATION ScoreSource = "ANNOTATION"
	API        ScoreSource = "API"
	EVAL       ScoreSource = "EVAL"
)

// Defines values for ScoreV10DataType.
const (
	ScoreV10DataTypeNUMERIC ScoreV10DataType = "NUMERIC"
)

// Defines values for ScoreV11DataType.
const (
	CATEGORICAL ScoreV11DataType = "CATEGORICAL"
)

// Defines values for ScoreV12DataType.
const (
	BOOLEAN ScoreV12DataType = "BOOLEAN"
)

// AnnotationQueue defines model for AnnotationQueue.
type AnnotationQueue struct {
	CreatedAt      time.Time `json:"createdAt"`
	Description    *string   `json:"description"`
	Id             string    `json:"id"`
	Name           string    `json:"name"`
	ScoreConfigIds []string  `json:"scoreConfigIds"`
	UpdatedAt      time.Time `json:"updatedAt"`
}

// AnnotationQueueItem defines model for AnnotationQueueItem.
type AnnotationQueueItem struct {
	CompletedAt *time.Time                `json:"completedAt"`
	CreatedAt   time.Time                 `json:"createdAt"`
	Id          string                    `json:"id"`
	ObjectId    string                    `json:"objectId"`
	ObjectType  AnnotationQueueObjectType `json:"objectType"`
	QueueId     string                    `json:"queueId"`
	Status      AnnotationQueueStatus     `json:"status"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
}

// AnnotationQueueObjectType defines model for AnnotationQueueObjectType.
type AnnotationQueueObjectType string

// AnnotationQueueStatus defines model for AnnotationQueueStatus.
type AnnotationQueueStatus string

// ApiKeyDeletionResponse Response for API key deletion
type ApiKeyDeletionResponse struct {
	Success bool `json:"success"`
}

// ApiKeyList List of API keys for a project
type ApiKeyList struct {
	ApiKeys []ApiKeySummary `json:"apiKeys"`
}

// ApiKeyResponse Response for API key creation
type ApiKeyResponse struct {
	CreatedAt        time.Time `json:"createdAt"`
	DisplaySecretKey string    `json:"displaySecretKey"`
	Id               string    `json:"id"`
	Note             *string   `json:"note"`
	PublicKey        string    `json:"publicKey"`
	SecretKey        string    `json:"secretKey"`
}

// ApiKeySummary Summary of an API key
type ApiKeySummary struct {
	CreatedAt        time.Time  `json:"createdAt"`
	DisplaySecretKey string     `json:"displaySecretKey"`
	ExpiresAt        *time.Time `json:"expiresAt"`
	Id               string     `json:"id"`
	LastUsedAt       *time.Time `json:"lastUsedAt"`
	Note             *string    `json:"note"`
	PublicKey        string     `json:"publicKey"`
}

// AuthenticationScheme defines model for AuthenticationScheme.
type AuthenticationScheme struct {
	Description string `json:"description"`
	Name        string `json:"name"`
	Primary     bool   `json:"primary"`
	SpecUri     string `json:"specUri"`
	Type        string `json:"type"`
}

// BaseEvent defines model for BaseEvent.
type BaseEvent struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string `json:"timestamp"`
}

// BasePrompt defines model for BasePrompt.
type BasePrompt struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// ResolutionGraph The dependency resolution graph for the current prompt. Null if prompt has no dependencies.
	ResolutionGraph *map[string]interface{} `json:"resolutionGraph"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string `json:"tags"`
	Version int      `json:"version"`
}

// BaseScore defines model for BaseScore.
type BaseScore struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string   `json:"configId"`
	CreatedAt    time.Time `json:"createdAt"`
	DatasetRunId *string   `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// BaseScoreV1 defines model for BaseScoreV1.
type BaseScoreV1 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId  *string   `json:"configId"`
	CreatedAt time.Time `json:"createdAt"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   string      `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// BooleanScore defines model for BooleanScore.
type BooleanScore = BaseScore

// BooleanScoreV1 defines model for BooleanScoreV1.
type BooleanScoreV1 = BaseScoreV1

// BulkConfig defines model for BulkConfig.
type BulkConfig struct {
	MaxOperations  int  `json:"maxOperations"`
	MaxPayloadSize int  `json:"maxPayloadSize"`
	Supported      bool `json:"supported"`
}

// CategoricalScore defines model for CategoricalScore.
type CategoricalScore = BaseScore

// CategoricalScoreV1 defines model for CategoricalScoreV1.
type CategoricalScoreV1 = BaseScoreV1

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	Content string `json:"content"`
	Role    string `json:"role"`
}

// ChatMessageWithPlaceholders defines model for ChatMessageWithPlaceholders.
type ChatMessageWithPlaceholders struct {
	union json.RawMessage
}

// ChatMessageWithPlaceholders0 defines model for .
type ChatMessageWithPlaceholders0 struct {
	Content string                            `json:"content"`
	Role    string                            `json:"role"`
	Type    *ChatMessageWithPlaceholders0Type `json:"type,omitempty"`
}

// ChatMessageWithPlaceholders0Type defines model for ChatMessageWithPlaceholders.0.Type.
type ChatMessageWithPlaceholders0Type string

// ChatMessageWithPlaceholders1 defines model for .
type ChatMessageWithPlaceholders1 struct {
	Name string                            `json:"name"`
	Type *ChatMessageWithPlaceholders1Type `json:"type,omitempty"`
}

// ChatMessageWithPlaceholders1Type defines model for ChatMessageWithPlaceholders.1.Type.
type ChatMessageWithPlaceholders1Type string

// ChatPrompt defines model for ChatPrompt.
type ChatPrompt = BasePrompt

// Comment defines model for Comment.
type Comment struct {
	AuthorUserId *string           `json:"authorUserId"`
	Content      string            `json:"content"`
	CreatedAt    time.Time         `json:"createdAt"`
	Id           string            `json:"id"`
	ObjectId     string            `json:"objectId"`
	ObjectType   CommentObjectType `json:"objectType"`
	ProjectId    string            `json:"projectId"`
	UpdatedAt    time.Time         `json:"updatedAt"`
}

// CommentObjectType defines model for CommentObjectType.
type CommentObjectType string

// ConfigCategory defines model for ConfigCategory.
type ConfigCategory struct {
	Label string  `json:"label"`
	Value float64 `json:"value"`
}

// CreateAnnotationQueueItemRequest defines model for CreateAnnotationQueueItemRequest.
type CreateAnnotationQueueItemRequest struct {
	ObjectId   string                    `json:"objectId"`
	ObjectType AnnotationQueueObjectType `json:"objectType"`
	Status     *AnnotationQueueStatus    `json:"status,omitempty"`
}

// CreateChatPromptRequest defines model for CreateChatPromptRequest.
type CreateChatPromptRequest struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string                     `json:"labels"`
	Name   string                        `json:"name"`
	Prompt []ChatMessageWithPlaceholders `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string `json:"tags"`
}

// CreateCommentRequest defines model for CreateCommentRequest.
type CreateCommentRequest struct {
	// AuthorUserId The id of the user who created the comment.
	AuthorUserId *string `json:"authorUserId"`

	// Content The content of the comment. May include markdown. Currently limited to 3000 characters.
	Content string `json:"content"`

	// ObjectId The id of the object to attach the comment to. If this does not reference a valid existing object, an error will be thrown.
	ObjectId string `json:"objectId"`

	// ObjectType The type of the object to attach the comment to (trace, observation, session, prompt).
	ObjectType string `json:"objectType"`

	// ProjectId The id of the project to attach the comment to.
	ProjectId string `json:"projectId"`
}

// CreateCommentResponse defines model for CreateCommentResponse.
type CreateCommentResponse struct {
	// Id The id of the created object in Langfuse
	Id string `json:"id"`
}

// CreateDatasetItemRequest defines model for CreateDatasetItemRequest.
type CreateDatasetItemRequest struct {
	DatasetName    string      `json:"datasetName"`
	ExpectedOutput interface{} `json:"expectedOutput"`

	// Id Dataset items are upserted on their id. Id needs to be unique (project-level) and cannot be reused across datasets.
	Id                  *string        `json:"id"`
	Input               interface{}    `json:"input"`
	Metadata            interface{}    `json:"metadata"`
	SourceObservationId *string        `json:"sourceObservationId"`
	SourceTraceId       *string        `json:"sourceTraceId"`
	Status              *DatasetStatus `json:"status,omitempty"`
}

// CreateDatasetRequest defines model for CreateDatasetRequest.
type CreateDatasetRequest struct {
	Description *string     `json:"description"`
	Metadata    interface{} `json:"metadata"`
	Name        string      `json:"name"`
}

// CreateDatasetRunItemRequest defines model for CreateDatasetRunItemRequest.
type CreateDatasetRunItemRequest struct {
	DatasetItemId string `json:"datasetItemId"`

	// Metadata Metadata of the dataset run, updates run if run already exists
	Metadata      interface{} `json:"metadata"`
	ObservationId *string     `json:"observationId"`

	// RunDescription Description of the run. If run exists, description will be updated.
	RunDescription *string `json:"runDescription"`
	RunName        string  `json:"runName"`

	// TraceId traceId should always be provided. For compatibility with older SDK versions it can also be inferred from the provided observationId.
	TraceId *string `json:"traceId"`
}

// CreateEventBody defines model for CreateEventBody.
type CreateEventBody = OptionalObservationBody

// CreateEventEvent defines model for CreateEventEvent.
type CreateEventEvent = BaseEvent

// CreateGenerationBody defines model for CreateGenerationBody.
type CreateGenerationBody = CreateSpanBody

// CreateGenerationEvent defines model for CreateGenerationEvent.
type CreateGenerationEvent = BaseEvent

// CreateModelRequest defines model for CreateModelRequest.
type CreateModelRequest struct {
	// InputPrice Price (USD) per input unit
	InputPrice *float64 `json:"inputPrice"`

	// MatchPattern Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$`
	MatchPattern string `json:"matchPattern"`

	// ModelName Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime
	ModelName string `json:"modelName"`

	// OutputPrice Price (USD) per output unit
	OutputPrice *float64 `json:"outputPrice"`

	// StartDate Apply only to generations which are newer than this ISO date.
	StartDate *time.Time `json:"startDate"`

	// TokenizerConfig Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.
	TokenizerConfig interface{} `json:"tokenizerConfig"`

	// TokenizerId Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
	TokenizerId *string `json:"tokenizerId"`

	// TotalPrice Price (USD) per total units. Cannot be set if input or output price is set.
	TotalPrice *float64 `json:"totalPrice"`

	// Unit Unit of usage in Langfuse
	Unit *ModelUsageUnit `json:"unit,omitempty"`
}

// CreateObservationEvent defines model for CreateObservationEvent.
type CreateObservationEvent = BaseEvent

// CreatePromptRequest defines model for CreatePromptRequest.
type CreatePromptRequest struct {
	union json.RawMessage
}

// CreatePromptRequest0 defines model for .
type CreatePromptRequest0 struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string                     `json:"labels"`
	Name   string                        `json:"name"`
	Prompt []ChatMessageWithPlaceholders `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string                 `json:"tags"`
	Type *CreatePromptRequest0Type `json:"type,omitempty"`
}

// CreatePromptRequest0Type defines model for CreatePromptRequest.0.Type.
type CreatePromptRequest0Type string

// CreatePromptRequest1 defines model for .
type CreatePromptRequest1 struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string `json:"labels"`
	Name   string    `json:"name"`
	Prompt string    `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string                 `json:"tags"`
	Type *CreatePromptRequest1Type `json:"type,omitempty"`
}

// CreatePromptRequest1Type defines model for CreatePromptRequest.1.Type.
type CreatePromptRequest1Type string

// CreateScoreConfigRequest defines model for CreateScoreConfigRequest.
type CreateScoreConfigRequest struct {
	// Categories Configure custom categories for categorical scores. Pass a list of objects with `label` and `value` properties. Categories are autogenerated for boolean configs and cannot be passed
	Categories *[]ConfigCategory `json:"categories"`
	DataType   ScoreDataType     `json:"dataType"`

	// Description Description is shown across the Langfuse UI and can be used to e.g. explain the config categories in detail, why a numeric range was set, or provide additional context on config name or usage
	Description *string `json:"description"`

	// MaxValue Configure a maximum value for numerical scores. If not set, the maximum value defaults to +∞
	MaxValue *float64 `json:"maxValue"`

	// MinValue Configure a minimum value for numerical scores. If not set, the minimum value defaults to -∞
	MinValue *float64 `json:"minValue"`
	Name     string   `json:"name"`
}

// CreateScoreRequest defines model for CreateScoreRequest.
type CreateScoreRequest struct {
	Comment *string `json:"comment"`

	// ConfigId Reference a score config on a score. The unique langfuse identifier of a score config. When passing this field, the dataType and stringValue fields are automatically populated.
	ConfigId     *string        `json:"configId"`
	DataType     *ScoreDataType `json:"dataType,omitempty"`
	DatasetRunId *string        `json:"datasetRunId"`

	// Environment The environment of the score. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            *string     `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`
	SessionId     *string     `json:"sessionId"`
	TraceId       *string     `json:"traceId"`

	// Value The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
	Value CreateScoreValue `json:"value"`
}

// CreateScoreResponse defines model for CreateScoreResponse.
type CreateScoreResponse struct {
	// Id The id of the created object in Langfuse
	Id string `json:"id"`
}

// CreateScoreValue The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
type CreateScoreValue struct {
	union json.RawMessage
}

// CreateScoreValue0 defines model for .
type CreateScoreValue0 = float64

// CreateScoreValue1 defines model for .
type CreateScoreValue1 = string

// CreateSpanBody defines model for CreateSpanBody.
type CreateSpanBody = CreateEventBody

// CreateSpanEvent defines model for CreateSpanEvent.
type CreateSpanEvent = BaseEvent

// CreateTextPromptRequest defines model for CreateTextPromptRequest.
type CreateTextPromptRequest struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string `json:"labels"`
	Name   string    `json:"name"`
	Prompt string    `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string `json:"tags"`
}

// Dataset defines model for Dataset.
type Dataset struct {
	CreatedAt   time.Time   `json:"createdAt"`
	Description *string     `json:"description"`
	Id          string      `json:"id"`
	Metadata    interface{} `json:"metadata"`
	Name        string      `json:"name"`
	ProjectId   string      `json:"projectId"`
	UpdatedAt   time.Time   `json:"updatedAt"`
}

// DatasetItem defines model for DatasetItem.
type DatasetItem struct {
	CreatedAt           time.Time     `json:"createdAt"`
	DatasetId           string        `json:"datasetId"`
	DatasetName         string        `json:"datasetName"`
	ExpectedOutput      interface{}   `json:"expectedOutput"`
	Id                  string        `json:"id"`
	Input               interface{}   `json:"input"`
	Metadata            interface{}   `json:"metadata"`
	SourceObservationId *string       `json:"sourceObservationId"`
	SourceTraceId       *string       `json:"sourceTraceId"`
	Status              DatasetStatus `json:"status"`
	UpdatedAt           time.Time     `json:"updatedAt"`
}

// DatasetRun defines model for DatasetRun.
type DatasetRun struct {
	// CreatedAt The date and time when the dataset run was created
	CreatedAt time.Time `json:"createdAt"`

	// DatasetId Id of the associated dataset
	DatasetId string `json:"datasetId"`

	// DatasetName Name of the associated dataset
	DatasetName string `json:"datasetName"`

	// Description Description of the run
	Description *string `json:"description"`

	// Id Unique identifier of the dataset run
	Id string `json:"id"`

	// Metadata Metadata of the dataset run
	Metadata interface{} `json:"metadata"`

	// Name Name of the dataset run
	Name string `json:"name"`

	// UpdatedAt The date and time when the dataset run was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// DatasetRunItem defines model for DatasetRunItem.
type DatasetRunItem struct {
	CreatedAt      time.Time `json:"createdAt"`
	DatasetItemId  string    `json:"datasetItemId"`
	DatasetRunId   string    `json:"datasetRunId"`
	DatasetRunName string    `json:"datasetRunName"`
	Id             string    `json:"id"`
	ObservationId  *string   `json:"observationId"`
	TraceId        string    `json:"traceId"`
	UpdatedAt      time.Time `json:"updatedAt"`
}

// DatasetRunWithItems defines model for DatasetRunWithItems.
type DatasetRunWithItems = DatasetRun

// DatasetStatus defines model for DatasetStatus.
type DatasetStatus string

// DeleteAnnotationQueueItemResponse defines model for DeleteAnnotationQueueItemResponse.
type DeleteAnnotationQueueItemResponse struct {
	Message string `json:"message"`
	Success bool   `json:"success"`
}

// DeleteDatasetItemResponse defines model for DeleteDatasetItemResponse.
type DeleteDatasetItemResponse struct {
	// Message Success message after deletion
	Message string `json:"message"`
}

// DeleteDatasetRunResponse defines model for DeleteDatasetRunResponse.
type DeleteDatasetRunResponse struct {
	Message string `json:"message"`
}

// DeleteTraceResponse defines model for DeleteTraceResponse.
type DeleteTraceResponse struct {
	Message string `json:"message"`
}

// EmptyResponse Empty response for 204 No Content responses
type EmptyResponse = map[string]interface{}

// FilterConfig defines model for FilterConfig.
type FilterConfig struct {
	MaxResults int  `json:"maxResults"`
	Supported  bool `json:"supported"`
}

// GetCommentsResponse defines model for GetCommentsResponse.
type GetCommentsResponse struct {
	Data []Comment         `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// GetMediaResponse defines model for GetMediaResponse.
type GetMediaResponse struct {
	// ContentLength The size of the media record in bytes
	ContentLength int `json:"contentLength"`

	// ContentType The MIME type of the media record
	ContentType string `json:"contentType"`

	// MediaId The unique langfuse identifier of a media record
	MediaId string `json:"mediaId"`

	// UploadedAt The date and time when the media record was uploaded
	UploadedAt time.Time `json:"uploadedAt"`

	// Url The download URL of the media record
	Url string `json:"url"`

	// UrlExpiry The expiry date and time of the media record download URL
	UrlExpiry string `json:"urlExpiry"`
}

// GetMediaUploadUrlRequest defines model for GetMediaUploadUrlRequest.
type GetMediaUploadUrlRequest struct {
	// ContentLength The size of the media record in bytes
	ContentLength int `json:"contentLength"`

	// ContentType The MIME type of the media record
	ContentType MediaContentType `json:"contentType"`

	// Field The trace / observation field the media record is associated with. This can be one of `input`, `output`, `metadata`
	Field string `json:"field"`

	// ObservationId The observation ID associated with the media record. If the media record is associated directly with a trace, this will be null.
	ObservationId *string `json:"observationId"`

	// Sha256Hash The SHA-256 hash of the media record
	Sha256Hash string `json:"sha256Hash"`

	// TraceId The trace ID associated with the media record
	TraceId string `json:"traceId"`
}

// GetMediaUploadUrlResponse defines model for GetMediaUploadUrlResponse.
type GetMediaUploadUrlResponse struct {
	// MediaId The unique langfuse identifier of a media record
	MediaId string `json:"mediaId"`

	// UploadUrl The presigned upload URL. If the asset is already uploaded, this will be null
	UploadUrl *string `json:"uploadUrl"`
}

// GetScoresResponse defines model for GetScoresResponse.
type GetScoresResponse struct {
	Data []GetScoresResponseData `json:"data"`
	Meta UtilsMetaResponse       `json:"meta"`
}

// GetScoresResponseData defines model for GetScoresResponseData.
type GetScoresResponseData struct {
	union json.RawMessage
}

// GetScoresResponseData0 defines model for .
type GetScoresResponseData0 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string                         `json:"configId"`
	CreatedAt    time.Time                       `json:"createdAt"`
	DataType     *GetScoresResponseData0DataType `json:"dataType,omitempty"`
	DatasetRunId *string                         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// GetScoresResponseData0DataType defines model for GetScoresResponseData.0.DataType.
type GetScoresResponseData0DataType string

// GetScoresResponseData1 defines model for .
type GetScoresResponseData1 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string                         `json:"configId"`
	CreatedAt    time.Time                       `json:"createdAt"`
	DataType     *GetScoresResponseData1DataType `json:"dataType,omitempty"`
	DatasetRunId *string                         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// GetScoresResponseData1DataType defines model for GetScoresResponseData.1.DataType.
type GetScoresResponseData1DataType string

// GetScoresResponseData2 defines model for .
type GetScoresResponseData2 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string                         `json:"configId"`
	CreatedAt    time.Time                       `json:"createdAt"`
	DataType     *GetScoresResponseData2DataType `json:"dataType,omitempty"`
	DatasetRunId *string                         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// GetScoresResponseData2DataType defines model for GetScoresResponseData.2.DataType.
type GetScoresResponseData2DataType string

// GetScoresResponseDataBoolean defines model for GetScoresResponseDataBoolean.
type GetScoresResponseDataBoolean = BooleanScore

// GetScoresResponseDataCategorical defines model for GetScoresResponseDataCategorical.
type GetScoresResponseDataCategorical = CategoricalScore

// GetScoresResponseDataNumeric defines model for GetScoresResponseDataNumeric.
type GetScoresResponseDataNumeric = NumericScore

// GetScoresResponseTraceData defines model for GetScoresResponseTraceData.
type GetScoresResponseTraceData struct {
	// Environment The environment of the trace referenced by score
	Environment *string `json:"environment"`

	// Tags A list of tags associated with the trace referenced by score
	Tags *[]string `json:"tags"`

	// UserId The user ID associated with the trace referenced by score
	UserId *string `json:"userId"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Status string `json:"status"`

	// Version Langfuse server version
	Version string `json:"version"`
}

// IngestionError defines model for IngestionError.
type IngestionError struct {
	Error   interface{} `json:"error"`
	Id      string      `json:"id"`
	Message *string     `json:"message"`
	Status  int         `json:"status"`
}

// IngestionEvent defines model for IngestionEvent.
type IngestionEvent struct {
	union json.RawMessage
}

// IngestionEvent0 defines model for .
type IngestionEvent0 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent0Type `json:"type,omitempty"`
}

// IngestionEvent0Type defines model for IngestionEvent.0.Type.
type IngestionEvent0Type string

// IngestionEvent1 defines model for .
type IngestionEvent1 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent1Type `json:"type,omitempty"`
}

// IngestionEvent1Type defines model for IngestionEvent.1.Type.
type IngestionEvent1Type string

// IngestionEvent2 defines model for .
type IngestionEvent2 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent2Type `json:"type,omitempty"`
}

// IngestionEvent2Type defines model for IngestionEvent.2.Type.
type IngestionEvent2Type string

// IngestionEvent3 defines model for .
type IngestionEvent3 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent3Type `json:"type,omitempty"`
}

// IngestionEvent3Type defines model for IngestionEvent.3.Type.
type IngestionEvent3Type string

// IngestionEvent4 defines model for .
type IngestionEvent4 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent4Type `json:"type,omitempty"`
}

// IngestionEvent4Type defines model for IngestionEvent.4.Type.
type IngestionEvent4Type string

// IngestionEvent5 defines model for .
type IngestionEvent5 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent5Type `json:"type,omitempty"`
}

// IngestionEvent5Type defines model for IngestionEvent.5.Type.
type IngestionEvent5Type string

// IngestionEvent6 defines model for .
type IngestionEvent6 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent6Type `json:"type,omitempty"`
}

// IngestionEvent6Type defines model for IngestionEvent.6.Type.
type IngestionEvent6Type string

// IngestionEvent7 defines model for .
type IngestionEvent7 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent7Type `json:"type,omitempty"`
}

// IngestionEvent7Type defines model for IngestionEvent.7.Type.
type IngestionEvent7Type string

// IngestionEvent8 defines model for .
type IngestionEvent8 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent8Type `json:"type,omitempty"`
}

// IngestionEvent8Type defines model for IngestionEvent.8.Type.
type IngestionEvent8Type string

// IngestionEvent9 defines model for .
type IngestionEvent9 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent9Type `json:"type,omitempty"`
}

// IngestionEvent9Type defines model for IngestionEvent.9.Type.
type IngestionEvent9Type string

// IngestionResponse defines model for IngestionResponse.
type IngestionResponse struct {
	Errors    []IngestionError   `json:"errors"`
	Successes []IngestionSuccess `json:"successes"`
}

// IngestionSuccess defines model for IngestionSuccess.
type IngestionSuccess struct {
	Id     string `json:"id"`
	Status int    `json:"status"`
}

// IngestionUsage defines model for IngestionUsage.
type IngestionUsage struct {
	union json.RawMessage
}

// MapValue defines model for MapValue.
type MapValue struct {
	union json.RawMessage
}

// MapValue0 defines model for .
type MapValue0 = string

// MapValue1 defines model for .
type MapValue1 = int

// MapValue2 defines model for .
type MapValue2 = bool

// MapValue3 defines model for .
type MapValue3 = []string

// MediaContentType The MIME type of the media record
type MediaContentType string

// MembershipRequest defines model for MembershipRequest.
type MembershipRequest struct {
	Role   MembershipRole `json:"role"`
	UserId string         `json:"userId"`
}

// MembershipResponse defines model for MembershipResponse.
type MembershipResponse struct {
	Email  string         `json:"email"`
	Name   string         `json:"name"`
	Role   MembershipRole `json:"role"`
	UserId string         `json:"userId"`
}

// MembershipRole defines model for MembershipRole.
type MembershipRole string

// MembershipsResponse defines model for MembershipsResponse.
type MembershipsResponse struct {
	Memberships []MembershipResponse `json:"memberships"`
}

// MetricsResponse defines model for MetricsResponse.
type MetricsResponse struct {
	// Data The metrics data. Each item in the list contains the metric values and dimensions requested in the query.
	// Format varies based on the query parameters.
	// Histograms will return an array with [lower, upper, height] tuples.
	Data []map[string]interface{} `json:"data"`
}

// Model Model definition used for transforming usage into USD cost and/or tokenization.
type Model struct {
	Id string `json:"id"`

	// InputPrice Deprecated. See 'prices' instead. Price (USD) per input unit
	InputPrice        *float64 `json:"inputPrice"`
	IsLangfuseManaged bool     `json:"isLangfuseManaged"`

	// MatchPattern Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$`
	MatchPattern string `json:"matchPattern"`

	// ModelName Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime
	ModelName string `json:"modelName"`

	// OutputPrice Deprecated. See 'prices' instead. Price (USD) per output unit
	OutputPrice *float64 `json:"outputPrice"`

	// Prices Price (USD) by usage type
	Prices map[string]ModelPrice `json:"prices"`

	// StartDate Apply only to generations which are newer than this ISO date.
	StartDate *time.Time `json:"startDate"`

	// TokenizerConfig Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.
	TokenizerConfig interface{} `json:"tokenizerConfig"`

	// TokenizerId Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
	TokenizerId *string `json:"tokenizerId"`

	// TotalPrice Deprecated. See 'prices' instead. Price (USD) per total unit. Cannot be set if input or output price is set.
	TotalPrice *float64 `json:"totalPrice"`

	// Unit Unit of usage in Langfuse
	Unit *ModelUsageUnit `json:"unit,omitempty"`
}

// ModelPrice defines model for ModelPrice.
type ModelPrice struct {
	Price float64 `json:"price"`
}

// ModelUsageUnit Unit of usage in Langfuse
type ModelUsageUnit string

// NumericScore defines model for NumericScore.
type NumericScore = BaseScore

// NumericScoreV1 defines model for NumericScoreV1.
type NumericScoreV1 = BaseScoreV1

// Observation defines model for Observation.
type Observation struct {
	// CompletionStartTime The completion start time of the observation
	CompletionStartTime *time.Time `json:"completionStartTime"`

	// CostDetails The cost details of the observation. Key is the name of the cost metric, value is the cost in USD. The total key is the sum of all (non-total) cost metrics or the total value ingested.
	CostDetails *map[string]float64 `json:"costDetails"`

	// EndTime The end time of the observation.
	EndTime *time.Time `json:"endTime"`

	// Environment The environment from which this observation originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment *string `json:"environment"`

	// Id The unique identifier of the observation
	Id string `json:"id"`

	// Input The input data of the observation
	Input interface{}      `json:"input"`
	Level ObservationLevel `json:"level"`

	// Metadata Additional metadata of the observation
	Metadata interface{} `json:"metadata"`

	// Model The model used for the observation
	Model *string `json:"model"`

	// ModelParameters The parameters of the model used for the observation
	ModelParameters *map[string]MapValue `json:"modelParameters"`

	// Name The name of the observation
	Name *string `json:"name"`

	// Output The output data of the observation
	Output interface{} `json:"output"`

	// ParentObservationId The parent observation ID
	ParentObservationId *string `json:"parentObservationId"`

	// PromptId The prompt ID associated with the observation
	PromptId *string `json:"promptId"`

	// StartTime The start time of the observation
	StartTime time.Time `json:"startTime"`

	// StatusMessage The status message of the observation
	StatusMessage *string `json:"statusMessage"`

	// TraceId The trace ID associated with the observation
	TraceId *string `json:"traceId"`

	// Type The type of the observation
	Type string `json:"type"`

	// Usage (Deprecated. Use usageDetails and costDetails instead.) Standard interface for usage and cost
	Usage *Usage `json:"usage,omitempty"`

	// UsageDetails The usage details of the observation. Key is the name of the usage metric, value is the number of units consumed. The total key is the sum of all (non-total) usage metrics or the total value ingested.
	UsageDetails *map[string]int `json:"usageDetails"`

	// Version The version of the observation
	Version *string `json:"version"`
}

// ObservationBody defines model for ObservationBody.
type ObservationBody struct {
	CompletionStartTime *time.Time           `json:"completionStartTime"`
	EndTime             *time.Time           `json:"endTime"`
	Environment         *string              `json:"environment"`
	Id                  *string              `json:"id"`
	Input               interface{}          `json:"input"`
	Level               *ObservationLevel    `json:"level,omitempty"`
	Metadata            interface{}          `json:"metadata"`
	Model               *string              `json:"model"`
	ModelParameters     *map[string]MapValue `json:"modelParameters"`
	Name                *string              `json:"name"`
	Output              interface{}          `json:"output"`
	ParentObservationId *string              `json:"parentObservationId"`
	StartTime           *time.Time           `json:"startTime"`
	StatusMessage       *string              `json:"statusMessage"`
	TraceId             *string              `json:"traceId"`
	Type                ObservationType      `json:"type"`

	// Usage (Deprecated. Use usageDetails and costDetails instead.) Standard interface for usage and cost
	Usage   *Usage  `json:"usage,omitempty"`
	Version *string `json:"version"`
}

// ObservationLevel defines model for ObservationLevel.
type ObservationLevel string

// ObservationType defines model for ObservationType.
type ObservationType string

// ObservationsView defines model for ObservationsView.
type ObservationsView = Observation

// ObservationsViews defines model for ObservationsViews.
type ObservationsViews struct {
	Data []ObservationsView `json:"data"`
	Meta UtilsMetaResponse  `json:"meta"`
}

// OpenAICompletionUsageSchema OpenAI Usage schema from (Chat-)Completion APIs
type OpenAICompletionUsageSchema struct {
	CompletionTokens        int              `json:"completion_tokens"`
	CompletionTokensDetails *map[string]*int `json:"completion_tokens_details"`
	PromptTokens            int              `json:"prompt_tokens"`
	PromptTokensDetails     *map[string]*int `json:"prompt_tokens_details"`
	TotalTokens             int              `json:"total_tokens"`
}

// OpenAIResponseUsageSchema OpenAI Usage schema from Response API
type OpenAIResponseUsageSchema struct {
	InputTokens         int              `json:"input_tokens"`
	InputTokensDetails  *map[string]*int `json:"input_tokens_details"`
	OutputTokens        int              `json:"output_tokens"`
	OutputTokensDetails *map[string]*int `json:"output_tokens_details"`
	TotalTokens         int              `json:"total_tokens"`
}

// OpenAIUsage Usage interface of OpenAI for improved compatibility.
type OpenAIUsage struct {
	CompletionTokens *int `json:"completionTokens"`
	PromptTokens     *int `json:"promptTokens"`
	TotalTokens      *int `json:"totalTokens"`
}

// OptionalObservationBody defines model for OptionalObservationBody.
type OptionalObservationBody struct {
	Environment         *string           `json:"environment"`
	Input               interface{}       `json:"input"`
	Level               *ObservationLevel `json:"level,omitempty"`
	Metadata            interface{}       `json:"metadata"`
	Name                *string           `json:"name"`
	Output              interface{}       `json:"output"`
	ParentObservationId *string           `json:"parentObservationId"`
	StartTime           *time.Time        `json:"startTime"`
	StatusMessage       *string           `json:"statusMessage"`
	TraceId             *string           `json:"traceId"`
	Version             *string           `json:"version"`
}

// OrganizationProject defines model for OrganizationProject.
type OrganizationProject struct {
	CreatedAt time.Time               `json:"createdAt"`
	Id        string                  `json:"id"`
	Metadata  *map[string]interface{} `json:"metadata"`
	Name      string                  `json:"name"`
	UpdatedAt time.Time               `json:"updatedAt"`
}

// OrganizationProjectsResponse defines model for OrganizationProjectsResponse.
type OrganizationProjectsResponse struct {
	Projects []OrganizationProject `json:"projects"`
}

// PaginatedAnnotationQueueItems defines model for PaginatedAnnotationQueueItems.
type PaginatedAnnotationQueueItems struct {
	Data []AnnotationQueueItem `json:"data"`
	Meta UtilsMetaResponse     `json:"meta"`
}

// PaginatedAnnotationQueues defines model for PaginatedAnnotationQueues.
type PaginatedAnnotationQueues struct {
	Data []AnnotationQueue `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasetItems defines model for PaginatedDatasetItems.
type PaginatedDatasetItems struct {
	Data []DatasetItem     `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasetRunItems defines model for PaginatedDatasetRunItems.
type PaginatedDatasetRunItems struct {
	Data []DatasetRunItem  `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasetRuns defines model for PaginatedDatasetRuns.
type PaginatedDatasetRuns struct {
	Data []DatasetRun      `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasets defines model for PaginatedDatasets.
type PaginatedDatasets struct {
	Data []Dataset         `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedModels defines model for PaginatedModels.
type PaginatedModels struct {
	Data []Model           `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedSessions defines model for PaginatedSessions.
type PaginatedSessions struct {
	Data []Session         `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PatchMediaBody defines model for PatchMediaBody.
type PatchMediaBody struct {
	// UploadHttpError The HTTP error message of the upload
	UploadHttpError *string `json:"uploadHttpError"`

	// UploadHttpStatus The HTTP status code of the upload
	UploadHttpStatus int `json:"uploadHttpStatus"`

	// UploadTimeMs The time in milliseconds it took to upload the media record
	UploadTimeMs *int `json:"uploadTimeMs"`

	// UploadedAt The date and time when the media record was uploaded
	UploadedAt time.Time `json:"uploadedAt"`
}

// PlaceholderMessage defines model for PlaceholderMessage.
type PlaceholderMessage struct {
	Name string `json:"name"`
}

// Project defines model for Project.
type Project struct {
	Id string `json:"id"`

	// Metadata Metadata for the project
	Metadata map[string]interface{} `json:"metadata"`
	Name     string                 `json:"name"`

	// RetentionDays Number of days to retain data. Null or 0 means no retention. Omitted if no retention is configured.
	RetentionDays *int `json:"retentionDays"`
}

// ProjectDeletionResponse defines model for ProjectDeletionResponse.
type ProjectDeletionResponse struct {
	Message string `json:"message"`
	Success bool   `json:"success"`
}

// Projects defines model for Projects.
type Projects struct {
	Data []Project `json:"data"`
}

// Prompt defines model for Prompt.
type Prompt struct {
	union json.RawMessage
}

// Prompt0 defines model for .
type Prompt0 struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// ResolutionGraph The dependency resolution graph for the current prompt. Null if prompt has no dependencies.
	ResolutionGraph *map[string]interface{} `json:"resolutionGraph"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string     `json:"tags"`
	Type    *Prompt0Type `json:"type,omitempty"`
	Version int          `json:"version"`
}

// Prompt0Type defines model for Prompt.0.Type.
type Prompt0Type string

// Prompt1 defines model for .
type Prompt1 struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// ResolutionGraph The dependency resolution graph for the current prompt. Null if prompt has no dependencies.
	ResolutionGraph *map[string]interface{} `json:"resolutionGraph"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string     `json:"tags"`
	Type    *Prompt1Type `json:"type,omitempty"`
	Version int          `json:"version"`
}

// Prompt1Type defines model for Prompt.1.Type.
type Prompt1Type string

// PromptMeta defines model for PromptMeta.
type PromptMeta struct {
	Labels []string `json:"labels"`

	// LastConfig Config object of the most recent prompt version that matches the filters (if any are provided)
	LastConfig    interface{} `json:"lastConfig"`
	LastUpdatedAt time.Time   `json:"lastUpdatedAt"`
	Name          string      `json:"name"`
	Tags          []string    `json:"tags"`
	Versions      []int       `json:"versions"`
}

// PromptMetaListResponse defines model for PromptMetaListResponse.
type PromptMetaListResponse struct {
	Data []PromptMeta      `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// ResourceMeta defines model for ResourceMeta.
type ResourceMeta struct {
	Location     string `json:"location"`
	ResourceType string `json:"resourceType"`
}

// ResourceType defines model for ResourceType.
type ResourceType struct {
	Description      string            `json:"description"`
	Endpoint         string            `json:"endpoint"`
	Id               string            `json:"id"`
	Meta             ResourceMeta      `json:"meta"`
	Name             string            `json:"name"`
	Schema           string            `json:"schema"`
	SchemaExtensions []SchemaExtension `json:"schemaExtensions"`
	Schemas          *[]string         `json:"schemas"`
}

// ResourceTypesResponse defines model for ResourceTypesResponse.
type ResourceTypesResponse struct {
	Resources    []ResourceType `json:"Resources"`
	Schemas      []string       `json:"schemas"`
	TotalResults int            `json:"totalResults"`
}

// SDKLogBody defines model for SDKLogBody.
type SDKLogBody struct {
	Log interface{} `json:"log"`
}

// SDKLogEvent defines model for SDKLogEvent.
type SDKLogEvent = BaseEvent

// SchemaExtension defines model for SchemaExtension.
type SchemaExtension struct {
	Required bool   `json:"required"`
	Schema   string `json:"schema"`
}

// SchemaResource defines model for SchemaResource.
type SchemaResource struct {
	Attributes  []interface{} `json:"attributes"`
	Description string        `json:"description"`
	Id          string        `json:"id"`
	Meta        ResourceMeta  `json:"meta"`
	Name        string        `json:"name"`
}

// SchemasResponse defines model for SchemasResponse.
type SchemasResponse struct {
	Resources    []SchemaResource `json:"Resources"`
	Schemas      []string         `json:"schemas"`
	TotalResults int              `json:"totalResults"`
}

// ScimEmail defines model for ScimEmail.
type ScimEmail struct {
	Primary bool   `json:"primary"`
	Type    string `json:"type"`
	Value   string `json:"value"`
}

// ScimFeatureSupport defines model for ScimFeatureSupport.
type ScimFeatureSupport struct {
	Supported bool `json:"supported"`
}

// ScimName defines model for ScimName.
type ScimName struct {
	Formatted *string `json:"formatted"`
}

// ScimUser defines model for ScimUser.
type ScimUser struct {
	Emails   []ScimEmail `json:"emails"`
	Id       string      `json:"id"`
	Meta     UserMeta    `json:"meta"`
	Name     ScimName    `json:"name"`
	Schemas  []string    `json:"schemas"`
	UserName string      `json:"userName"`
}

// ScimUsersListResponse defines model for ScimUsersListResponse.
type ScimUsersListResponse struct {
	Resources    []ScimUser `json:"Resources"`
	ItemsPerPage int        `json:"itemsPerPage"`
	Schemas      []string   `json:"schemas"`
	StartIndex   int        `json:"startIndex"`
	TotalResults int        `json:"totalResults"`
}

// Score defines model for Score.
type Score struct {
	union json.RawMessage
}

// Score0 defines model for .
type Score0 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string         `json:"configId"`
	CreatedAt    time.Time       `json:"createdAt"`
	DataType     *Score0DataType `json:"dataType,omitempty"`
	DatasetRunId *string         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// Score0DataType defines model for Score.0.DataType.
type Score0DataType string

// Score1 defines model for .
type Score1 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string         `json:"configId"`
	CreatedAt    time.Time       `json:"createdAt"`
	DataType     *Score1DataType `json:"dataType,omitempty"`
	DatasetRunId *string         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// Score1DataType defines model for Score.1.DataType.
type Score1DataType string

// Score2 defines model for .
type Score2 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string         `json:"configId"`
	CreatedAt    time.Time       `json:"createdAt"`
	DataType     *Score2DataType `json:"dataType,omitempty"`
	DatasetRunId *string         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// Score2DataType defines model for Score.2.DataType.
type Score2DataType string

// ScoreBody defines model for ScoreBody.
type ScoreBody struct {
	Comment *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, the score name must equal the config name and scores must comply with the config's range and data type. For categorical scores, the value must map to a config category. Numeric scores might be constrained by the score config's max and min values
	ConfigId      *string        `json:"configId"`
	DataType      *ScoreDataType `json:"dataType,omitempty"`
	DatasetRunId  *string        `json:"datasetRunId"`
	Environment   *string        `json:"environment"`
	Id            *string        `json:"id"`
	Metadata      interface{}    `json:"metadata"`
	Name          string         `json:"name"`
	ObservationId *string        `json:"observationId"`
	SessionId     *string        `json:"sessionId"`
	TraceId       *string        `json:"traceId"`

	// Value The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
	Value CreateScoreValue `json:"value"`
}

// ScoreConfig Configuration for a score
type ScoreConfig struct {
	// Categories Configures custom categories for categorical scores
	Categories  *[]ConfigCategory `json:"categories"`
	CreatedAt   time.Time         `json:"createdAt"`
	DataType    ScoreDataType     `json:"dataType"`
	Description *string           `json:"description"`
	Id          string            `json:"id"`

	// IsArchived Whether the score config is archived. Defaults to false
	IsArchived bool `json:"isArchived"`

	// MaxValue Sets maximum value for numerical scores. If not set, the maximum value defaults to +∞
	MaxValue *float64 `json:"maxValue"`

	// MinValue Sets minimum value for numerical scores. If not set, the minimum value defaults to -∞
	MinValue  *float64  `json:"minValue"`
	Name      string    `json:"name"`
	ProjectId string    `json:"projectId"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// ScoreConfigs defines model for ScoreConfigs.
type ScoreConfigs struct {
	Data []ScoreConfig     `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// ScoreDataType defines model for ScoreDataType.
type ScoreDataType string

// ScoreEvent defines model for ScoreEvent.
type ScoreEvent = BaseEvent

// ScoreSource defines model for ScoreSource.
type ScoreSource string

// ScoreV1 defines model for ScoreV1.
type ScoreV1 struct {
	union json.RawMessage
}

// ScoreV10 defines model for .
type ScoreV10 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId  *string           `json:"configId"`
	CreatedAt time.Time         `json:"createdAt"`
	DataType  *ScoreV10DataType `json:"dataType,omitempty"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   string      `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// ScoreV10DataType defines model for ScoreV1.0.DataType.
type ScoreV10DataType string

// ScoreV11 defines model for .
type ScoreV11 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId  *string           `json:"configId"`
	CreatedAt time.Time         `json:"createdAt"`
	DataType  *ScoreV11DataType `json:"dataType,omitempty"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   string      `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// ScoreV11DataType defines model for ScoreV1.1.DataType.
type ScoreV11DataType string

// ScoreV12 defines model for .
type ScoreV12 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId  *string           `json:"configId"`
	CreatedAt time.Time         `json:"createdAt"`
	DataType  *ScoreV12DataType `json:"dataType,omitempty"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string     `json:"environment"`
	Id            string      `json:"id"`
	Metadata      interface{} `json:"metadata"`
	Name          string      `json:"name"`
	ObservationId *string     `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   string      `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// ScoreV12DataType defines model for ScoreV1.2.DataType.
type ScoreV12DataType string

// ServiceProviderConfig defines model for ServiceProviderConfig.
type ServiceProviderConfig struct {
	AuthenticationSchemes []AuthenticationScheme `json:"authenticationSchemes"`
	Bulk                  BulkConfig             `json:"bulk"`
	ChangePassword        ScimFeatureSupport     `json:"changePassword"`
	DocumentationUri      string                 `json:"documentationUri"`
	Etag                  ScimFeatureSupport     `json:"etag"`
	Filter                FilterConfig           `json:"filter"`
	Meta                  ResourceMeta           `json:"meta"`
	Patch                 ScimFeatureSupport     `json:"patch"`
	Schemas               []string               `json:"schemas"`
	Sort                  ScimFeatureSupport     `json:"sort"`
}

// Session defines model for Session.
type Session struct {
	CreatedAt time.Time `json:"createdAt"`

	// Environment The environment from which this session originated.
	Environment *string `json:"environment"`
	Id          string  `json:"id"`
	ProjectId   string  `json:"projectId"`
}

// SessionWithTraces defines model for SessionWithTraces.
type SessionWithTraces = Session

// TextPrompt defines model for TextPrompt.
type TextPrompt = BasePrompt

// Trace defines model for Trace.
type Trace struct {
	// Environment The environment from which this trace originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment *string `json:"environment"`

	// Id The unique identifier of a trace
	Id string `json:"id"`

	// Input The input data of the trace. Can be any JSON.
	Input interface{} `json:"input"`

	// Metadata The metadata associated with the trace. Can be any JSON.
	Metadata interface{} `json:"metadata"`

	// Name The name of the trace
	Name *string `json:"name"`

	// Output The output data of the trace. Can be any JSON.
	Output interface{} `json:"output"`

	// Public Public traces are accessible via url without login
	Public *bool `json:"public"`

	// Release The release version of the application when the trace was created
	Release *string `json:"release"`

	// SessionId The session identifier associated with the trace
	SessionId *string `json:"sessionId"`

	// Tags The tags associated with the trace. Can be an array of strings or null.
	Tags *[]string `json:"tags"`

	// Timestamp The timestamp when the trace was created
	Timestamp time.Time `json:"timestamp"`

	// UserId The user identifier associated with the trace
	UserId *string `json:"userId"`

	// Version The version of the trace
	Version *string `json:"version"`
}

// TraceBody defines model for TraceBody.
type TraceBody struct {
	Environment *string     `json:"environment"`
	Id          *string     `json:"id"`
	Input       interface{} `json:"input"`
	Metadata    interface{} `json:"metadata"`
	Name        *string     `json:"name"`
	Output      interface{} `json:"output"`

	// Public Make trace publicly accessible via url
	Public    *bool      `json:"public"`
	Release   *string    `json:"release"`
	SessionId *string    `json:"sessionId"`
	Tags      *[]string  `json:"tags"`
	Timestamp *time.Time `json:"timestamp"`
	UserId    *string    `json:"userId"`
	Version   *string    `json:"version"`
}

// TraceEvent defines model for TraceEvent.
type TraceEvent = BaseEvent

// TraceWithDetails defines model for TraceWithDetails.
type TraceWithDetails = Trace

// TraceWithFullDetails defines model for TraceWithFullDetails.
type TraceWithFullDetails = Trace

// Traces defines model for Traces.
type Traces struct {
	Data []TraceWithDetails `json:"data"`
	Meta UtilsMetaResponse  `json:"meta"`
}

// UpdateAnnotationQueueItemRequest defines model for UpdateAnnotationQueueItemRequest.
type UpdateAnnotationQueueItemRequest struct {
	Status *AnnotationQueueStatus `json:"status,omitempty"`
}

// UpdateEventBody defines model for UpdateEventBody.
type UpdateEventBody = OptionalObservationBody

// UpdateGenerationBody defines model for UpdateGenerationBody.
type UpdateGenerationBody = UpdateSpanBody

// UpdateGenerationEvent defines model for UpdateGenerationEvent.
type UpdateGenerationEvent = BaseEvent

// UpdateObservationEvent defines model for UpdateObservationEvent.
type UpdateObservationEvent = BaseEvent

// UpdateSpanBody defines model for UpdateSpanBody.
type UpdateSpanBody = UpdateEventBody

// UpdateSpanEvent defines model for UpdateSpanEvent.
type UpdateSpanEvent = BaseEvent

// Usage (Deprecated. Use usageDetails and costDetails instead.) Standard interface for usage and cost
type Usage struct {
	// Input Number of input units (e.g. tokens)
	Input *int `json:"input"`

	// InputCost USD input cost
	InputCost *float64 `json:"inputCost"`

	// Output Number of output units (e.g. tokens)
	Output *int `json:"output"`

	// OutputCost USD output cost
	OutputCost *float64 `json:"outputCost"`

	// Total Defaults to input+output if not set
	Total *int `json:"total"`

	// TotalCost USD total cost, defaults to input+output
	TotalCost *float64 `json:"totalCost"`

	// Unit Unit of usage in Langfuse
	Unit *ModelUsageUnit `json:"unit,omitempty"`
}

// UsageDetails defines model for UsageDetails.
type UsageDetails struct {
	union json.RawMessage
}

// UsageDetails0 defines model for .
type UsageDetails0 map[string]int

// UserMeta defines model for UserMeta.
type UserMeta struct {
	Created      *string `json:"created"`
	LastModified *string `json:"lastModified"`
	ResourceType string  `json:"resourceType"`
}

// UtilsMetaResponse defines model for utilsMetaResponse.
type UtilsMetaResponse struct {
	// Limit number of items per page
	Limit int `json:"limit"`

	// Page current page number
	Page int `json:"page"`

	// TotalItems number of total items given the current filters/selection (if any)
	TotalItems int `json:"totalItems"`

	// TotalPages number of total pages given the current limit
	TotalPages int `json:"totalPages"`
}

// AnnotationQueuesListQueuesParams defines parameters for AnnotationQueuesListQueues.
type AnnotationQueuesListQueuesParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AnnotationQueuesListQueueItemsParams defines parameters for AnnotationQueuesListQueueItems.
type AnnotationQueuesListQueueItemsParams struct {
	// Status Filter by status
	Status *AnnotationQueueStatus `form:"status,omitempty" json:"status,omitempty"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// CommentsGetParams defines parameters for CommentsGet.
type CommentsGetParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// ObjectType Filter comments by object type (trace, observation, session, prompt).
	ObjectType *string `form:"objectType,omitempty" json:"objectType,omitempty"`

	// ObjectId Filter comments by object id. If objectType is not provided, an error will be thrown.
	ObjectId *string `form:"objectId,omitempty" json:"objectId,omitempty"`

	// AuthorUserId Filter comments by author user id.
	AuthorUserId *string `form:"authorUserId,omitempty" json:"authorUserId,omitempty"`
}

// DatasetItemsListParams defines parameters for DatasetItemsList.
type DatasetItemsListParams struct {
	DatasetName         *string `form:"datasetName,omitempty" json:"datasetName,omitempty"`
	SourceTraceId       *string `form:"sourceTraceId,omitempty" json:"sourceTraceId,omitempty"`
	SourceObservationId *string `form:"sourceObservationId,omitempty" json:"sourceObservationId,omitempty"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// DatasetRunItemsListParams defines parameters for DatasetRunItemsList.
type DatasetRunItemsListParams struct {
	DatasetId string `form:"datasetId" json:"datasetId"`
	RunName   string `form:"runName" json:"runName"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// DatasetsGetRunsParams defines parameters for DatasetsGetRuns.
type DatasetsGetRunsParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// IngestionBatchJSONBody defines parameters for IngestionBatch.
type IngestionBatchJSONBody struct {
	// Batch Batch of tracing events to be ingested. Discriminated by attribute `type`.
	Batch []IngestionEvent `json:"batch"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata interface{} `json:"metadata"`
}

// MetricsMetricsParams defines parameters for MetricsMetrics.
type MetricsMetricsParams struct {
	// Query JSON string containing the query parameters with the following structure:
	// ```json
	// {
	//   "view": string,           // Required. One of "traces", "observations", "scores-numeric", "scores-categorical"
	//   "dimensions": [           // Optional. Default: []
	//     {
	//       "field": string       // Field to group by, e.g. "name", "userId", "sessionId"
	//     }
	//   ],
	//   "metrics": [              // Required. At least one metric must be provided
	//     {
	//       "measure": string,    // What to measure, e.g. "count", "latency", "value"
	//       "aggregation": string // How to aggregate, e.g. "count", "sum", "avg", "p95", "histogram"
	//     }
	//   ],
	//   "filters": [              // Optional. Default: []
	//     {
	//       "column": string,     // Column to filter on
	//       "operator": string,   // Operator, e.g. "=", ">", "<", "contains"
	//       "value": any,         // Value to compare against
	//       "type": string,       // Data type, e.g. "string", "number", "stringObject"
	//       "key": string         // Required only when filtering on metadata
	//     }
	//   ],
	//   "timeDimension": {        // Optional. Default: null. If provided, results will be grouped by time
	//     "granularity": string   // One of "minute", "hour", "day", "week", "month", "auto"
	//   },
	//   "fromTimestamp": string,  // Required. ISO datetime string for start of time range
	//   "toTimestamp": string,    // Required. ISO datetime string for end of time range
	//   "orderBy": [              // Optional. Default: null
	//     {
	//       "field": string,      // Field to order by
	//       "direction": string   // "asc" or "desc"
	//     }
	//   ],
	//   "config": {               // Optional. Query-specific configuration
	//     "bins": number,         // Optional. Number of bins for histogram (1-100), default: 10
	//     "row_limit": number     // Optional. Row limit for results (1-1000)
	//   }
	// }
	// ```
	Query string `form:"query" json:"query"`
}

// ModelsListParams defines parameters for ModelsList.
type ModelsListParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ObservationsGetManyParams defines parameters for ObservationsGetMany.
type ObservationsGetManyParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit   *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Name    *string `form:"name,omitempty" json:"name,omitempty"`
	UserId  *string `form:"userId,omitempty" json:"userId,omitempty"`
	Type    *string `form:"type,omitempty" json:"type,omitempty"`
	TraceId *string `form:"traceId,omitempty" json:"traceId,omitempty"`

	// Level Optional filter for observations with a specific level (e.g. "DEBUG", "DEFAULT", "WARNING", "ERROR").
	Level               *ObservationLevel `form:"level,omitempty" json:"level,omitempty"`
	ParentObservationId *string           `form:"parentObservationId,omitempty" json:"parentObservationId,omitempty"`

	// Environment Optional filter for observations where the environment is one of the provided values.
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`

	// FromStartTime Retrieve only observations with a start_time on or after this datetime (ISO 8601).
	FromStartTime *time.Time `form:"fromStartTime,omitempty" json:"fromStartTime,omitempty"`

	// ToStartTime Retrieve only observations with a start_time before this datetime (ISO 8601).
	ToStartTime *time.Time `form:"toStartTime,omitempty" json:"toStartTime,omitempty"`

	// Version Optional filter to only include observations with a certain version.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// ProjectsCreateJSONBody defines parameters for ProjectsCreate.
type ProjectsCreateJSONBody struct {
	// Metadata Optional metadata for the project
	Metadata *map[string]interface{} `json:"metadata"`
	Name     string                  `json:"name"`

	// Retention Number of days to retain data. Must be 0 or at least 3 days. Requires data-retention entitlement for non-zero values. Optional.
	Retention int `json:"retention"`
}

// ProjectsUpdateJSONBody defines parameters for ProjectsUpdate.
type ProjectsUpdateJSONBody struct {
	// Metadata Optional metadata for the project
	Metadata *map[string]interface{} `json:"metadata"`
	Name     string                  `json:"name"`

	// Retention Number of days to retain data. Must be 0 or at least 3 days. Requires data-retention entitlement for non-zero values. Optional.
	Retention int `json:"retention"`
}

// ProjectsCreateApiKeyJSONBody defines parameters for ProjectsCreateApiKey.
type ProjectsCreateApiKeyJSONBody struct {
	// Note Optional note for the API key
	Note *string `json:"note"`
}

// ScimListUsersParams defines parameters for ScimListUsers.
type ScimListUsersParams struct {
	// Filter Filter expression (e.g. userName eq "value")
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// StartIndex 1-based index of the first result to return (default 1)
	StartIndex *int `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Maximum number of results to return (default 100)
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// ScimCreateUserJSONBody defines parameters for ScimCreateUser.
type ScimCreateUserJSONBody struct {
	// Active Whether the user is active
	Active *bool `json:"active"`

	// Emails User's email addresses
	Emails *[]ScimEmail `json:"emails"`
	Name   ScimName     `json:"name"`

	// Password Initial password for the user
	Password *string `json:"password"`

	// UserName User's email address (required)
	UserName string `json:"userName"`
}

// ScoreConfigsGetParams defines parameters for ScoreConfigsGet.
type ScoreConfigsGetParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// SessionsListParams defines parameters for SessionsList.
type SessionsListParams struct {
	// Page Page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// FromTimestamp Optional filter to only include sessions created on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include sessions created before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// Environment Optional filter for sessions where the environment is one of the provided values.
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`
}

// TraceDeleteMultipleJSONBody defines parameters for TraceDeleteMultiple.
type TraceDeleteMultipleJSONBody struct {
	// TraceIds List of trace IDs to delete
	TraceIds []string `json:"traceIds"`
}

// TraceListParams defines parameters for TraceList.
type TraceListParams struct {
	// Page Page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit     *int    `form:"limit,omitempty" json:"limit,omitempty"`
	UserId    *string `form:"userId,omitempty" json:"userId,omitempty"`
	Name      *string `form:"name,omitempty" json:"name,omitempty"`
	SessionId *string `form:"sessionId,omitempty" json:"sessionId,omitempty"`

	// FromTimestamp Optional filter to only include traces with a trace.timestamp on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include traces with a trace.timestamp before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// OrderBy Format of the string [field].[asc/desc]. Fields: id, timestamp, name, userId, release, version, public, bookmarked, sessionId. Example: timestamp.asc
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Tags Only traces that include all of these tags will be returned.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Version Optional filter to only include traces with a certain version.
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// Release Optional filter to only include traces with a certain release.
	Release *string `form:"release,omitempty" json:"release,omitempty"`

	// Environment Optional filter for traces where the environment is one of the provided values.
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`

	// Fields Comma-separated list of fields to include in the response. Available field groups are 'core' (always included), 'io' (input, output, metadata), 'scores', 'observations', 'metrics'. If not provided, all fields are included. Example: 'core,scores,metrics'
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DatasetsListParams defines parameters for DatasetsList.
type DatasetsListParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PromptsListParams defines parameters for PromptsList.
type PromptsListParams struct {
	Name  *string `form:"name,omitempty" json:"name,omitempty"`
	Label *string `form:"label,omitempty" json:"label,omitempty"`
	Tag   *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// FromUpdatedAt Optional filter to only include prompt versions created/updated on or after a certain datetime (ISO 8601)
	FromUpdatedAt *time.Time `form:"fromUpdatedAt,omitempty" json:"fromUpdatedAt,omitempty"`

	// ToUpdatedAt Optional filter to only include prompt versions created/updated before a certain datetime (ISO 8601)
	ToUpdatedAt *time.Time `form:"toUpdatedAt,omitempty" json:"toUpdatedAt,omitempty"`
}

// PromptVersionUpdateJSONBody defines parameters for PromptVersionUpdate.
type PromptVersionUpdateJSONBody struct {
	// NewLabels New labels for the prompt version. Labels are unique across versions. The "latest" label is reserved and managed by Langfuse.
	NewLabels []string `json:"newLabels"`
}

// PromptsGetParams defines parameters for PromptsGet.
type PromptsGetParams struct {
	// Version Version of the prompt to be retrieved.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// Label Label of the prompt to be retrieved. Defaults to "production" if no label or version is set.
	Label *string `form:"label,omitempty" json:"label,omitempty"`
}

// ScoreV2GetParams defines parameters for ScoreV2Get.
type ScoreV2GetParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// UserId Retrieve only scores with this userId associated to the trace.
	UserId *string `form:"userId,omitempty" json:"userId,omitempty"`

	// Name Retrieve only scores with this name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// FromTimestamp Optional filter to only include scores created on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include scores created before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// Environment Optional filter for scores where the environment is one of the provided values.
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`

	// Source Retrieve only scores from a specific source.
	Source *ScoreSource `form:"source,omitempty" json:"source,omitempty"`

	// Operator Retrieve only scores with <operator> value.
	Operator *string `form:"operator,omitempty" json:"operator,omitempty"`

	// Value Retrieve only scores with <operator> value.
	Value *float64 `form:"value,omitempty" json:"value,omitempty"`

	// ScoreIds Comma-separated list of score IDs to limit the results to.
	ScoreIds *string `form:"scoreIds,omitempty" json:"scoreIds,omitempty"`

	// ConfigId Retrieve only scores with a specific configId.
	ConfigId *string `form:"configId,omitempty" json:"configId,omitempty"`

	// QueueId Retrieve only scores with a specific annotation queueId.
	QueueId *string `form:"queueId,omitempty" json:"queueId,omitempty"`

	// DataType Retrieve only scores with a specific dataType.
	DataType *ScoreDataType `form:"dataType,omitempty" json:"dataType,omitempty"`

	// TraceTags Only scores linked to traces that include all of these tags will be returned.
	TraceTags *[]string `form:"traceTags,omitempty" json:"traceTags,omitempty"`
}

// AnnotationQueuesCreateQueueItemJSONRequestBody defines body for AnnotationQueuesCreateQueueItem for application/json ContentType.
type AnnotationQueuesCreateQueueItemJSONRequestBody = CreateAnnotationQueueItemRequest

// AnnotationQueuesUpdateQueueItemJSONRequestBody defines body for AnnotationQueuesUpdateQueueItem for application/json ContentType.
type AnnotationQueuesUpdateQueueItemJSONRequestBody = UpdateAnnotationQueueItemRequest

// CommentsCreateJSONRequestBody defines body for CommentsCreate for application/json ContentType.
type CommentsCreateJSONRequestBody = CreateCommentRequest

// DatasetItemsCreateJSONRequestBody defines body for DatasetItemsCreate for application/json ContentType.
type DatasetItemsCreateJSONRequestBody = CreateDatasetItemRequest

// DatasetRunItemsCreateJSONRequestBody defines body for DatasetRunItemsCreate for application/json ContentType.
type DatasetRunItemsCreateJSONRequestBody = CreateDatasetRunItemRequest

// IngestionBatchJSONRequestBody defines body for IngestionBatch for application/json ContentType.
type IngestionBatchJSONRequestBody IngestionBatchJSONBody

// MediaGetUploadUrlJSONRequestBody defines body for MediaGetUploadUrl for application/json ContentType.
type MediaGetUploadUrlJSONRequestBody = GetMediaUploadUrlRequest

// MediaPatchJSONRequestBody defines body for MediaPatch for application/json ContentType.
type MediaPatchJSONRequestBody = PatchMediaBody

// ModelsCreateJSONRequestBody defines body for ModelsCreate for application/json ContentType.
type ModelsCreateJSONRequestBody = CreateModelRequest

// OrganizationsUpdateOrganizationMembershipJSONRequestBody defines body for OrganizationsUpdateOrganizationMembership for application/json ContentType.
type OrganizationsUpdateOrganizationMembershipJSONRequestBody = MembershipRequest

// ProjectsCreateJSONRequestBody defines body for ProjectsCreate for application/json ContentType.
type ProjectsCreateJSONRequestBody ProjectsCreateJSONBody

// ProjectsUpdateJSONRequestBody defines body for ProjectsUpdate for application/json ContentType.
type ProjectsUpdateJSONRequestBody ProjectsUpdateJSONBody

// ProjectsCreateApiKeyJSONRequestBody defines body for ProjectsCreateApiKey for application/json ContentType.
type ProjectsCreateApiKeyJSONRequestBody ProjectsCreateApiKeyJSONBody

// OrganizationsUpdateProjectMembershipJSONRequestBody defines body for OrganizationsUpdateProjectMembership for application/json ContentType.
type OrganizationsUpdateProjectMembershipJSONRequestBody = MembershipRequest

// ScimCreateUserJSONRequestBody defines body for ScimCreateUser for application/json ContentType.
type ScimCreateUserJSONRequestBody ScimCreateUserJSONBody

// ScoreConfigsCreateJSONRequestBody defines body for ScoreConfigsCreate for application/json ContentType.
type ScoreConfigsCreateJSONRequestBody = CreateScoreConfigRequest

// ScoreCreateJSONRequestBody defines body for ScoreCreate for application/json ContentType.
type ScoreCreateJSONRequestBody = CreateScoreRequest

// TraceDeleteMultipleJSONRequestBody defines body for TraceDeleteMultiple for application/json ContentType.
type TraceDeleteMultipleJSONRequestBody TraceDeleteMultipleJSONBody

// DatasetsCreateJSONRequestBody defines body for DatasetsCreate for application/json ContentType.
type DatasetsCreateJSONRequestBody = CreateDatasetRequest

// PromptsCreateJSONRequestBody defines body for PromptsCreate for application/json ContentType.
type PromptsCreateJSONRequestBody = CreatePromptRequest

// PromptVersionUpdateJSONRequestBody defines body for PromptVersionUpdate for application/json ContentType.
type PromptVersionUpdateJSONRequestBody PromptVersionUpdateJSONBody

// AsChatMessageWithPlaceholders0 returns the union data inside the ChatMessageWithPlaceholders as a ChatMessageWithPlaceholders0
func (t ChatMessageWithPlaceholders) AsChatMessageWithPlaceholders0() (ChatMessageWithPlaceholders0, error) {
	var body ChatMessageWithPlaceholders0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMessageWithPlaceholders0 overwrites any union data inside the ChatMessageWithPlaceholders as the provided ChatMessageWithPlaceholders0
func (t *ChatMessageWithPlaceholders) FromChatMessageWithPlaceholders0(v ChatMessageWithPlaceholders0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMessageWithPlaceholders0 performs a merge with any union data inside the ChatMessageWithPlaceholders, using the provided ChatMessageWithPlaceholders0
func (t *ChatMessageWithPlaceholders) MergeChatMessageWithPlaceholders0(v ChatMessageWithPlaceholders0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatMessageWithPlaceholders1 returns the union data inside the ChatMessageWithPlaceholders as a ChatMessageWithPlaceholders1
func (t ChatMessageWithPlaceholders) AsChatMessageWithPlaceholders1() (ChatMessageWithPlaceholders1, error) {
	var body ChatMessageWithPlaceholders1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMessageWithPlaceholders1 overwrites any union data inside the ChatMessageWithPlaceholders as the provided ChatMessageWithPlaceholders1
func (t *ChatMessageWithPlaceholders) FromChatMessageWithPlaceholders1(v ChatMessageWithPlaceholders1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMessageWithPlaceholders1 performs a merge with any union data inside the ChatMessageWithPlaceholders, using the provided ChatMessageWithPlaceholders1
func (t *ChatMessageWithPlaceholders) MergeChatMessageWithPlaceholders1(v ChatMessageWithPlaceholders1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatMessageWithPlaceholders) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatMessageWithPlaceholders) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreatePromptRequest0 returns the union data inside the CreatePromptRequest as a CreatePromptRequest0
func (t CreatePromptRequest) AsCreatePromptRequest0() (CreatePromptRequest0, error) {
	var body CreatePromptRequest0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePromptRequest0 overwrites any union data inside the CreatePromptRequest as the provided CreatePromptRequest0
func (t *CreatePromptRequest) FromCreatePromptRequest0(v CreatePromptRequest0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePromptRequest0 performs a merge with any union data inside the CreatePromptRequest, using the provided CreatePromptRequest0
func (t *CreatePromptRequest) MergeCreatePromptRequest0(v CreatePromptRequest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreatePromptRequest1 returns the union data inside the CreatePromptRequest as a CreatePromptRequest1
func (t CreatePromptRequest) AsCreatePromptRequest1() (CreatePromptRequest1, error) {
	var body CreatePromptRequest1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePromptRequest1 overwrites any union data inside the CreatePromptRequest as the provided CreatePromptRequest1
func (t *CreatePromptRequest) FromCreatePromptRequest1(v CreatePromptRequest1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePromptRequest1 performs a merge with any union data inside the CreatePromptRequest, using the provided CreatePromptRequest1
func (t *CreatePromptRequest) MergeCreatePromptRequest1(v CreatePromptRequest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePromptRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePromptRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateScoreValue0 returns the union data inside the CreateScoreValue as a CreateScoreValue0
func (t CreateScoreValue) AsCreateScoreValue0() (CreateScoreValue0, error) {
	var body CreateScoreValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateScoreValue0 overwrites any union data inside the CreateScoreValue as the provided CreateScoreValue0
func (t *CreateScoreValue) FromCreateScoreValue0(v CreateScoreValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateScoreValue0 performs a merge with any union data inside the CreateScoreValue, using the provided CreateScoreValue0
func (t *CreateScoreValue) MergeCreateScoreValue0(v CreateScoreValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateScoreValue1 returns the union data inside the CreateScoreValue as a CreateScoreValue1
func (t CreateScoreValue) AsCreateScoreValue1() (CreateScoreValue1, error) {
	var body CreateScoreValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateScoreValue1 overwrites any union data inside the CreateScoreValue as the provided CreateScoreValue1
func (t *CreateScoreValue) FromCreateScoreValue1(v CreateScoreValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateScoreValue1 performs a merge with any union data inside the CreateScoreValue, using the provided CreateScoreValue1
func (t *CreateScoreValue) MergeCreateScoreValue1(v CreateScoreValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateScoreValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateScoreValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetScoresResponseData0 returns the union data inside the GetScoresResponseData as a GetScoresResponseData0
func (t GetScoresResponseData) AsGetScoresResponseData0() (GetScoresResponseData0, error) {
	var body GetScoresResponseData0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetScoresResponseData0 overwrites any union data inside the GetScoresResponseData as the provided GetScoresResponseData0
func (t *GetScoresResponseData) FromGetScoresResponseData0(v GetScoresResponseData0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetScoresResponseData0 performs a merge with any union data inside the GetScoresResponseData, using the provided GetScoresResponseData0
func (t *GetScoresResponseData) MergeGetScoresResponseData0(v GetScoresResponseData0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetScoresResponseData1 returns the union data inside the GetScoresResponseData as a GetScoresResponseData1
func (t GetScoresResponseData) AsGetScoresResponseData1() (GetScoresResponseData1, error) {
	var body GetScoresResponseData1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetScoresResponseData1 overwrites any union data inside the GetScoresResponseData as the provided GetScoresResponseData1
func (t *GetScoresResponseData) FromGetScoresResponseData1(v GetScoresResponseData1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetScoresResponseData1 performs a merge with any union data inside the GetScoresResponseData, using the provided GetScoresResponseData1
func (t *GetScoresResponseData) MergeGetScoresResponseData1(v GetScoresResponseData1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetScoresResponseData2 returns the union data inside the GetScoresResponseData as a GetScoresResponseData2
func (t GetScoresResponseData) AsGetScoresResponseData2() (GetScoresResponseData2, error) {
	var body GetScoresResponseData2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetScoresResponseData2 overwrites any union data inside the GetScoresResponseData as the provided GetScoresResponseData2
func (t *GetScoresResponseData) FromGetScoresResponseData2(v GetScoresResponseData2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetScoresResponseData2 performs a merge with any union data inside the GetScoresResponseData, using the provided GetScoresResponseData2
func (t *GetScoresResponseData) MergeGetScoresResponseData2(v GetScoresResponseData2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetScoresResponseData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetScoresResponseData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIngestionEvent0 returns the union data inside the IngestionEvent as a IngestionEvent0
func (t IngestionEvent) AsIngestionEvent0() (IngestionEvent0, error) {
	var body IngestionEvent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent0 overwrites any union data inside the IngestionEvent as the provided IngestionEvent0
func (t *IngestionEvent) FromIngestionEvent0(v IngestionEvent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent0 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent0
func (t *IngestionEvent) MergeIngestionEvent0(v IngestionEvent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent1 returns the union data inside the IngestionEvent as a IngestionEvent1
func (t IngestionEvent) AsIngestionEvent1() (IngestionEvent1, error) {
	var body IngestionEvent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent1 overwrites any union data inside the IngestionEvent as the provided IngestionEvent1
func (t *IngestionEvent) FromIngestionEvent1(v IngestionEvent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent1 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent1
func (t *IngestionEvent) MergeIngestionEvent1(v IngestionEvent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent2 returns the union data inside the IngestionEvent as a IngestionEvent2
func (t IngestionEvent) AsIngestionEvent2() (IngestionEvent2, error) {
	var body IngestionEvent2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent2 overwrites any union data inside the IngestionEvent as the provided IngestionEvent2
func (t *IngestionEvent) FromIngestionEvent2(v IngestionEvent2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent2 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent2
func (t *IngestionEvent) MergeIngestionEvent2(v IngestionEvent2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent3 returns the union data inside the IngestionEvent as a IngestionEvent3
func (t IngestionEvent) AsIngestionEvent3() (IngestionEvent3, error) {
	var body IngestionEvent3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent3 overwrites any union data inside the IngestionEvent as the provided IngestionEvent3
func (t *IngestionEvent) FromIngestionEvent3(v IngestionEvent3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent3 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent3
func (t *IngestionEvent) MergeIngestionEvent3(v IngestionEvent3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent4 returns the union data inside the IngestionEvent as a IngestionEvent4
func (t IngestionEvent) AsIngestionEvent4() (IngestionEvent4, error) {
	var body IngestionEvent4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent4 overwrites any union data inside the IngestionEvent as the provided IngestionEvent4
func (t *IngestionEvent) FromIngestionEvent4(v IngestionEvent4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent4 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent4
func (t *IngestionEvent) MergeIngestionEvent4(v IngestionEvent4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent5 returns the union data inside the IngestionEvent as a IngestionEvent5
func (t IngestionEvent) AsIngestionEvent5() (IngestionEvent5, error) {
	var body IngestionEvent5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent5 overwrites any union data inside the IngestionEvent as the provided IngestionEvent5
func (t *IngestionEvent) FromIngestionEvent5(v IngestionEvent5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent5 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent5
func (t *IngestionEvent) MergeIngestionEvent5(v IngestionEvent5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent6 returns the union data inside the IngestionEvent as a IngestionEvent6
func (t IngestionEvent) AsIngestionEvent6() (IngestionEvent6, error) {
	var body IngestionEvent6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent6 overwrites any union data inside the IngestionEvent as the provided IngestionEvent6
func (t *IngestionEvent) FromIngestionEvent6(v IngestionEvent6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent6 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent6
func (t *IngestionEvent) MergeIngestionEvent6(v IngestionEvent6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent7 returns the union data inside the IngestionEvent as a IngestionEvent7
func (t IngestionEvent) AsIngestionEvent7() (IngestionEvent7, error) {
	var body IngestionEvent7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent7 overwrites any union data inside the IngestionEvent as the provided IngestionEvent7
func (t *IngestionEvent) FromIngestionEvent7(v IngestionEvent7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent7 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent7
func (t *IngestionEvent) MergeIngestionEvent7(v IngestionEvent7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent8 returns the union data inside the IngestionEvent as a IngestionEvent8
func (t IngestionEvent) AsIngestionEvent8() (IngestionEvent8, error) {
	var body IngestionEvent8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent8 overwrites any union data inside the IngestionEvent as the provided IngestionEvent8
func (t *IngestionEvent) FromIngestionEvent8(v IngestionEvent8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent8 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent8
func (t *IngestionEvent) MergeIngestionEvent8(v IngestionEvent8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent9 returns the union data inside the IngestionEvent as a IngestionEvent9
func (t IngestionEvent) AsIngestionEvent9() (IngestionEvent9, error) {
	var body IngestionEvent9
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent9 overwrites any union data inside the IngestionEvent as the provided IngestionEvent9
func (t *IngestionEvent) FromIngestionEvent9(v IngestionEvent9) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent9 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent9
func (t *IngestionEvent) MergeIngestionEvent9(v IngestionEvent9) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IngestionEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IngestionEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUsage returns the union data inside the IngestionUsage as a Usage
func (t IngestionUsage) AsUsage() (Usage, error) {
	var body Usage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsage overwrites any union data inside the IngestionUsage as the provided Usage
func (t *IngestionUsage) FromUsage(v Usage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsage performs a merge with any union data inside the IngestionUsage, using the provided Usage
func (t *IngestionUsage) MergeUsage(v Usage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAIUsage returns the union data inside the IngestionUsage as a OpenAIUsage
func (t IngestionUsage) AsOpenAIUsage() (OpenAIUsage, error) {
	var body OpenAIUsage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAIUsage overwrites any union data inside the IngestionUsage as the provided OpenAIUsage
func (t *IngestionUsage) FromOpenAIUsage(v OpenAIUsage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAIUsage performs a merge with any union data inside the IngestionUsage, using the provided OpenAIUsage
func (t *IngestionUsage) MergeOpenAIUsage(v OpenAIUsage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IngestionUsage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IngestionUsage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMapValue0 returns the union data inside the MapValue as a MapValue0
func (t MapValue) AsMapValue0() (MapValue0, error) {
	var body MapValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue0 overwrites any union data inside the MapValue as the provided MapValue0
func (t *MapValue) FromMapValue0(v MapValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue0 performs a merge with any union data inside the MapValue, using the provided MapValue0
func (t *MapValue) MergeMapValue0(v MapValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue1 returns the union data inside the MapValue as a MapValue1
func (t MapValue) AsMapValue1() (MapValue1, error) {
	var body MapValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue1 overwrites any union data inside the MapValue as the provided MapValue1
func (t *MapValue) FromMapValue1(v MapValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue1 performs a merge with any union data inside the MapValue, using the provided MapValue1
func (t *MapValue) MergeMapValue1(v MapValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue2 returns the union data inside the MapValue as a MapValue2
func (t MapValue) AsMapValue2() (MapValue2, error) {
	var body MapValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue2 overwrites any union data inside the MapValue as the provided MapValue2
func (t *MapValue) FromMapValue2(v MapValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue2 performs a merge with any union data inside the MapValue, using the provided MapValue2
func (t *MapValue) MergeMapValue2(v MapValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue3 returns the union data inside the MapValue as a MapValue3
func (t MapValue) AsMapValue3() (MapValue3, error) {
	var body MapValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue3 overwrites any union data inside the MapValue as the provided MapValue3
func (t *MapValue) FromMapValue3(v MapValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue3 performs a merge with any union data inside the MapValue, using the provided MapValue3
func (t *MapValue) MergeMapValue3(v MapValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MapValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MapValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrompt0 returns the union data inside the Prompt as a Prompt0
func (t Prompt) AsPrompt0() (Prompt0, error) {
	var body Prompt0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrompt0 overwrites any union data inside the Prompt as the provided Prompt0
func (t *Prompt) FromPrompt0(v Prompt0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrompt0 performs a merge with any union data inside the Prompt, using the provided Prompt0
func (t *Prompt) MergePrompt0(v Prompt0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrompt1 returns the union data inside the Prompt as a Prompt1
func (t Prompt) AsPrompt1() (Prompt1, error) {
	var body Prompt1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrompt1 overwrites any union data inside the Prompt as the provided Prompt1
func (t *Prompt) FromPrompt1(v Prompt1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrompt1 performs a merge with any union data inside the Prompt, using the provided Prompt1
func (t *Prompt) MergePrompt1(v Prompt1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Prompt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Prompt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScore0 returns the union data inside the Score as a Score0
func (t Score) AsScore0() (Score0, error) {
	var body Score0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore0 overwrites any union data inside the Score as the provided Score0
func (t *Score) FromScore0(v Score0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore0 performs a merge with any union data inside the Score, using the provided Score0
func (t *Score) MergeScore0(v Score0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScore1 returns the union data inside the Score as a Score1
func (t Score) AsScore1() (Score1, error) {
	var body Score1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore1 overwrites any union data inside the Score as the provided Score1
func (t *Score) FromScore1(v Score1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore1 performs a merge with any union data inside the Score, using the provided Score1
func (t *Score) MergeScore1(v Score1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScore2 returns the union data inside the Score as a Score2
func (t Score) AsScore2() (Score2, error) {
	var body Score2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore2 overwrites any union data inside the Score as the provided Score2
func (t *Score) FromScore2(v Score2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore2 performs a merge with any union data inside the Score, using the provided Score2
func (t *Score) MergeScore2(v Score2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Score) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Score) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScoreV10 returns the union data inside the ScoreV1 as a ScoreV10
func (t ScoreV1) AsScoreV10() (ScoreV10, error) {
	var body ScoreV10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScoreV10 overwrites any union data inside the ScoreV1 as the provided ScoreV10
func (t *ScoreV1) FromScoreV10(v ScoreV10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScoreV10 performs a merge with any union data inside the ScoreV1, using the provided ScoreV10
func (t *ScoreV1) MergeScoreV10(v ScoreV10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScoreV11 returns the union data inside the ScoreV1 as a ScoreV11
func (t ScoreV1) AsScoreV11() (ScoreV11, error) {
	var body ScoreV11
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScoreV11 overwrites any union data inside the ScoreV1 as the provided ScoreV11
func (t *ScoreV1) FromScoreV11(v ScoreV11) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScoreV11 performs a merge with any union data inside the ScoreV1, using the provided ScoreV11
func (t *ScoreV1) MergeScoreV11(v ScoreV11) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScoreV12 returns the union data inside the ScoreV1 as a ScoreV12
func (t ScoreV1) AsScoreV12() (ScoreV12, error) {
	var body ScoreV12
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScoreV12 overwrites any union data inside the ScoreV1 as the provided ScoreV12
func (t *ScoreV1) FromScoreV12(v ScoreV12) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScoreV12 performs a merge with any union data inside the ScoreV1, using the provided ScoreV12
func (t *ScoreV1) MergeScoreV12(v ScoreV12) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScoreV1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScoreV1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUsageDetails0 returns the union data inside the UsageDetails as a UsageDetails0
func (t UsageDetails) AsUsageDetails0() (UsageDetails0, error) {
	var body UsageDetails0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsageDetails0 overwrites any union data inside the UsageDetails as the provided UsageDetails0
func (t *UsageDetails) FromUsageDetails0(v UsageDetails0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsageDetails0 performs a merge with any union data inside the UsageDetails, using the provided UsageDetails0
func (t *UsageDetails) MergeUsageDetails0(v UsageDetails0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAICompletionUsageSchema returns the union data inside the UsageDetails as a OpenAICompletionUsageSchema
func (t UsageDetails) AsOpenAICompletionUsageSchema() (OpenAICompletionUsageSchema, error) {
	var body OpenAICompletionUsageSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAICompletionUsageSchema overwrites any union data inside the UsageDetails as the provided OpenAICompletionUsageSchema
func (t *UsageDetails) FromOpenAICompletionUsageSchema(v OpenAICompletionUsageSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAICompletionUsageSchema performs a merge with any union data inside the UsageDetails, using the provided OpenAICompletionUsageSchema
func (t *UsageDetails) MergeOpenAICompletionUsageSchema(v OpenAICompletionUsageSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAIResponseUsageSchema returns the union data inside the UsageDetails as a OpenAIResponseUsageSchema
func (t UsageDetails) AsOpenAIResponseUsageSchema() (OpenAIResponseUsageSchema, error) {
	var body OpenAIResponseUsageSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAIResponseUsageSchema overwrites any union data inside the UsageDetails as the provided OpenAIResponseUsageSchema
func (t *UsageDetails) FromOpenAIResponseUsageSchema(v OpenAIResponseUsageSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAIResponseUsageSchema performs a merge with any union data inside the UsageDetails, using the provided OpenAIResponseUsageSchema
func (t *UsageDetails) MergeOpenAIResponseUsageSchema(v OpenAIResponseUsageSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UsageDetails) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UsageDetails) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
